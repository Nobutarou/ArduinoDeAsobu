# レジスタのビットのコントロール

PIC のように REGISTERbits.BIT という書式はない。ないけど、ビット指定でコントロールはできる。

PORTB レジスタの 5番ビットである PORTB5 ビットを例にする。PORTB5 ビットは D13, ビルトインLED だ。

## ビットをクリア (0) したい

最終的には、

```
#define cbi(addr, bit) addr &= ~(1 << bit) 

cbi(PORTB, PORTB5);
```

順番に見て行く。define は sed みたいな文字列置換をしているだけなので、演算子を = の前に出
す書き方も元に戻すと、こうなる。

```
//PORTB &= ~(1<<PORTB5);
PORTB = PORTB & ~(1<<PORTB5);
```

``1<<PORTB5`` で 1 をPORTB5 のところまでずらすので、PORTB5 のみ 1 で他は 0 という 2進数になる。

```
PORTB = PORTB & ~0b00100000;
```

そして ``~`` はビットの反転なの
で PORTB5 のみ 0、他が 1 となる。

```
PORTB = PORTB & 0b11011111;
```

& (AND) の演算結果は次の通りなので、書き換え前がなんであろうが、太字の狙ったところだけを 0 にで
きる。

| 0/1 | AND | 0/1 | = |
| --- | --- | --- | - |
| 0   | AND | ***0***   | 0 |
| 0   | AND | 1   | 0 |
| 1   | AND | ***0***   | 0 |
| 1   | AND | 1   | 1 |

## 1 にしたい

最終はこうなる。

```
#define sbi(addr, bit) addr |=  (1 << bit)  // addrのbit目を'1'にする

sbi(PORTB, PORTB5);
```

順番にばらすとこうなる

```
//PORTB = PORTB | (1<<PORTB5);
PORTB = PORTB | 0b00100000;
```

``|`` (OR) の演算は次の通りなので、これも狙ったところだけ 1 にできる。

| 0/1 | OR  | 0/1 | = |
| --- | --- | --- | - |
| 0   | OR  | 0   | 0 |
| 0   | OR  | ***1***   | 1 |
| 1   | OR  | 0   | 1 |
| 1   | OR  | ***1***   | 1 |

## 反転したい

やはり最終形から。

```
#define rbi(addr,bit) addr ^= (1 << bit)

rbi(PORTB, PORTB5);
```

ばらすと

```
//PORTB = PORTB ^ (1 << PORTB5);
PORTB = PORTB ^ 0b00100000;
```

``^`` XOR 演算は次の結果となるので、狙ったところをひっくり返すことができる。

| 0/1 | XOR | 0/1 | = |
| --- | --- | --- | - |
| 0   | XOR | 0   | 0 |
| 0   | XOR | ***1***   | 1 |
| 1   | XOR | 0   | 1 |
| 1   | XOR | ***1***   | 0 |

## 調べたい

最終形

```
#define chkbi(addr,bit) ((addr >> bit) & 1)^1

chkbi(PORTB,PORTB5);
```

これもバラすと

```
char i; //とりあえず代入式にしておく

//i = ((PORTB>>PORTB5) & 1)^2;
```

``PORTB >> PORTB5`` は 2進数の PORTB レジスタを PORTB5 が 1桁目にくるところまで右にずらすという意味になる。
