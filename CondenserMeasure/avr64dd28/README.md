# AVR64DD28 版 1.0 RC回路 (いろいろ考えたけどボツ)
<!-- {{{ -->
[ATMega328用に作っていた](../RC直列回路計算.md) が、AVR64DD28 開発ボードが動いたので、作り
なおしてみる。

せっかくなので、時定数 t=RC まで待つ (Vc が 64.2%) としていたが、t=2.3RC (Vc が 90%) まで
待つでも良いのではないか。少しでも時間を稼ぐために。

[ADC が最速で 1回、9.1us](../../MiconBoards/AVR64DD28/README.md) くらいなので 1pF を 1サイク
ルで判定しようとすると、 1サイクルで判定しようとすると、4.7MΩくらいか。2.3RC=10.8us なの
で、ほぼほぼ 1サイクル。自分が使う範囲だと水晶とのペアで 15pF とか 22pF 使うかんじで、動作
確認が取れれば良いだけなので、十分ではないかな。

なぜ ATmega328P のときの 10MΩを考えていないかと言うと、基準抵抗を 3個使っていたが、2個に
減らせないかな、というのと、抵抗が大きいほど抵抗自身の浮遊容量が大きくなってしまう (100MΩ
とかまともに使えなかった) ところで、少し下げたい気持があった。

| 基準抵抗[Ω] | C [F] | 2.3RC[sec] | ADC サイクル数 |
| ---          | ---   | ---        | ---            |
| 4.7M         |  1p   |  10.8u     |  1             |
| 4.7M         | 10p   |  108u      |  12            |
| 4.7M         | 100p  |  1.08m     |  119           |
| 4.7M         | 1000p |  10.8m     |  1187          |
| 4.7M         | 0.01u |   108m     |  11868         |
| 4.7M         |  0.1u |  1.08      |  118681        |
| 2.2k         | 0.22u |  1.11m     |  122           |
| 2.2k         |  2.2u |  11.1m     |  1220          |
| 2.2k         |   22u |   111m     |  12198         |
| 2.2k         |  220u |   1.11     |  121978        |

ということで大きい方から 0.22uF までは 2.2kΩに任せて、それより小さいのは 4.7MΩに任せると
いうのでどうだろう。

放電はもともと 300Ωで、完全充電を過程して放電時間を決めている。なので、これはこのままで良
いかな (最大 16mA の放電)。放電時刻は抵抗値に比例なので 220Ω (最大 23mA) とかにしても、そ
れほど影響がない。

あと出力に関して、LCD の I2C 化前だったので、I2C 接続に変更する。

[回路図](./v1.0/kicad/CapMeter_AVR64DD28_1.0/CapMeter_AVR64DD28_1.0.pdf)

と
[ソース](./v1.0/arduino/CMeterAVR64DD28_1.0/CMeterAVR64DD28_1.0.ino)
を書いていて気づいたのだが digitalWrite() を高速化するためにレジスタ操作にした。

それから、放電時間を調べて放電ピンだけから放電してたけど、放電ピンよりも抵抗の小さいところ
はないので、全部から放電で構わないし、放電時間調べなくても analogRead() で 1/500 とかにな
るのを待てば良くね、ということで放電時間は計算しないことにした。

で良く分からないのだが、R2 で測定するとき C1 を Hi に出力、C0, D2 は Input なので浮かせて
いる積り。つまり電圧的には Vctest に等しいという認識なのだが、C0 が 0V となる。これは
PORTC.OUT のレジスタ操作でも digitalWrite() でも変わらない。

pinMode(PIN_PC0,INPUT) の状態で digitalWrite(PIN_PC0,HIGH) とすると 3.3V くらいになる。ど
うも中途半端に PORTC.OUT の影響を受けてしまっているように見える。

試しに R1 を別ポートの A6 に繋いでみたけど改善しない。なので同じポートが悪いわけではない。
また。R3 300Ωの D2 ポートは浮いている用に見える。

となると R1 の 4.7MΩというのが悪いのかもと思い、2.7kΩ挿してみたら普通に浮いたように見え
る。

ちょっと分かった。アナログの電圧計で考えると、実際に電圧を観測しているのではなくて、わずか
に流れる電流を電圧に換算している。マイコンのピンだって電圧を観測しているのではなく、なんだ
かんだ電流を電圧に換算しているのではないだろうか。それで 4.7MΩだと、電圧として反応するだ
けの電流が流れないということになるのではないだろうか。要は、実質的に絶縁状態ということにな
るのではなかろうか。

ATMega328P 版が動いていたのは、たまたま入力ピンの挙動が、そうなってほしい方向にあっただけ
で偶然のようだ。

とか思って[検証](../../MiconBoards/AVR64DD28/) してみたけど、どうもデジタル入力ピンが絶縁
されていないのではなく、analogRead() が電流を流してしまっていそうだ、という結論になった。

[実際に確認してみた](../../MiconBoards/AVR64DD28/) が今回のように analogRead を掛け続けて
いる場合は、電圧が下がることが分かった。

というかデータシートの 38.17 のADC 電気特性に Input resistance = 1kΩって書いてあった。
ATMega328P はデータシートの 29.8 に analog input resistance = 100MΩってある。

なるほど、大きな抵抗を使った RC 回路の測定は ATMega328P の方が適していたのだな。

<!-- }}} -->

# AVR64DD28 版 2.0 C直列回路

ざっくり動作判定できれば良いので、直列に繋いだらどうだろうか。
[計算式はこちら](./C直列回路.md)

手持ちが 15pF から 220uF。一回り大きく取ると 4.7pF ~ 470uF で 10,000,000倍の差がある。100
倍の基準コンデンサ、470pF と 4.7uF で考えると 2個で済む。 

そこで (4095-ADC)/ADC で ADC が 1変化した時の誤差を調べてみた。両端でも判定はできそう。さ
すが 12bit。そもそも基準コンデンサの容量が±10% とかだし。

| ADC の読み | (4095-ADC)/ADC | (4095-ADC+1)/(ADC-1) | 一致率 |
| ---        | ---            | ---                  | ---    |
| 4096       | 2.443e-4       | 4.886e-4             | 2.00   |
| 4085       | 2.448e-3       | 2.693e-3             | 1.10   |
| 4073       | 5.401e-3       | 5.648e-3             | 1.05   |
| 4048       | 1.161e-2       | 1.186e-2             | 1.02   |
| 3995       | 2.503e-2       | 2.529e-2             | 1.01   |

| ADC の読み | (4095-ADC)/ADC | (4095-ADC-1)/(ADC+1) | 一致率 |
| ---        | ---            | ---                  | ---    |
| 1          | 4.094e3        | 2.047e3              | 2.00   |
| 10         | 4.085e2        | 3.712e2              | 1.10   |
| 22         | 1.851e2        | 1.770e2              | 1.05   |          
| 47         | 8.613e1        | 8.431e1              | 1.02   |
| 100        | 3.995e1        | 3.954e1              | 1.01   |

[回路図](./v2.0/CapMeterAvr64_v2.0/CapMeterAvr64_v2.0.pdf)

1. PC0, PC2, PD1 を output low で放電。PC1, PC3, PD2 で analogRead で放電完了判定。
1. PC0,PD1 は input で絶縁。PC2 を output high で充電。PC3 で充電完了判定して PD2 で電圧読
   み取り
1. 放電
1. PC2, PD1 は input で絶縁、PC0 を output high で充電。PC1,PD2 で判定と測定
1. 放電

基準コンデンサが直列になってるけど、小さい方に引っ張られるので、C1 と C2 で 470pF からは
468.85pF と誤差にもならない。

[TinkerCAD の Arduino Uno R3 では動いた](https://www.tinkercad.com/things/6FRR9RiKOJp-)。

速度を気にしないから Arduino 命令だけで書けるところが Arduino らしくて良いのかもしれない。

と思って試しているのだけど、そもそも analogRead の挙動がおかしくない?
v1.0 が動かないのも analogRead がおかしいからだったりしない？
もしかして自分で ADC 動かさないと駄目？
どうも PC, PA は変。PD は大丈夫。PF は調査していない。

[こちら](../../MiconBoards/AVR64DD28/README.md) で調査したところヒューズbit が間違っていた。
直したら動いた。

[設計図](./v2.0/CapMeterAvr64_v2.0.pdf)

部品表:

| 記号 | 品名、品目 | 個数 |
| --- | --- | --- |
| B1 | ユニバーサル基板 13x9P | 1 |
| C1 | 4.7uF (精度良さ目のセラコン) | 1 |
| C2 | 470pF (精度良さ目のセラコン) | 1 |
| H1 | ピンヘッダ 5P | 1 |
| H2-6 | ピンヘッダ 2P | 4 |
| (H3) | (ヘッダとして使わないので低いヘッダが良い) | (1) |
| H7 | ピンヘッダ 1P | 1 |
| H8 | ピンヘッダー 3P | 1 |
| R1-3 | 220Ωより上。適当でいい | 3 |
| X1 | XP 2P ポスト | 1 |

# v3.0 RC回路のコンパレータ版

コンパレータなら datasheet の 38.18 によると ピンに 5nA くらい流れるようだ。5V で 5nA だか
ら、内部抵抗は 100MΩとなる。5V で nA だから、内部抵抗は 100MΩとなる。5V で nA だから、内
部抵抗は 100MΩとなる。5V で nA だから、内部抵抗は 100MΩとなる。5V で 5nA なら、内部抵抗
は 1000MΩ相当となる。これなら 4.7MΩを繋いでもビクともしないだろう。

また立ち上がりは 85ns 0.085us であり、
[digitalRead()の計測](../../MiconBoards/AVR64DD28/arduino/FuncSpeedTest/) 
では 0.25us。ADC よりも高速な動作が期待できる。
