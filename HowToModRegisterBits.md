# レジスタのビット書き換え

## 仕組み

PIC のように REGISTERbits.BIT という書式はない。

* クリアしたいビットは、そこだけ 0、他を 1 にして & (かつ) 演算する
* 1 にしたいビットは、そこだけ 1 にして | (または) 演算する

次の表の様に、残したいビットに 1、クリアしたいビットに 0 を指定し
て & 演算すれば、残したいところは残り、クリアしたいところだけクリアできる。

|     |     | 元    | ←    | コメント |
| --- | --- | ---   | ---   | ---      |
|     |     | 1     | 0     |          |
| 新  | 1   | **1** | **0** | 元が残る |
| ↑  | 0   |   0   |   0   | クリアできる |

残したいビットに 0、立てたいビットに 1 を指定して | 演算すれば、立てたいところだけ 1に書き
換えできる。

|     |     | 元    | ←    | コメント |
| --- | --- | ---   | ---   | ---      |
|     |     | 1     | 0     |          |
| 新  | 1   |  1    | 1     | 新の値に |
| ↑  | 0   | **1** | **0** | 元のまま |

## 例

REGISTER の下位 3ビットを 101 にしたいなら、

```
# とりあえず下位 2 番目のビットをクリア
REGISTER = REGISTER & 0b11111101;

# 下位 3 番目と 1番目を 1 に
REGISTER = REGISTER | 0b00000101;
```

## ビット名を指定した書き方

REGISTER レジスタの BIT ビットをクリアする場合、例えば 3ビット目にあるとして ``0b11111011`` と
& 演算となるが、この ``0b11111011`` は ``~(1 << BIT)`` と表記できる。``1<<BIT`` は 1 を
BIT の位置までずらすと言う意味で他は 0、つまり ``0b00000100`` と同意である。そして ``~``
を付けると 0, 1 を入れ替えるので ``0b11111011`` となる。また ``REGISTER = REGISTER &`` のとこ
ろは ``REGISTER &= `` と書ける。つまり以下の書式は等価である。ビット名が使える上に、なんか
分かっている感がすごい。

```
REGISTER = REGISTER & 0b11111011;
REGISTER &= ~(1<<BIT);
```

同様に以下も等価である。

```
REGISTER = REGISTER | 0b00000100; 
REGISTER |= (1<<BIT);
```

また define マクロ (sed のようなもの) を使って、このように入力を楽にしている人々も見つかる。
Arduino のソースで使われている（もしくは使われていた）形のようだ。

```
#define cbi(addr, bit) addr &= ~(1 << bit)  // addrのbit目を'0'にする
#define sbi(addr, bit) addr |=  (1 << bit)  // addrのbit目を'1'にする

cbi(REGISTER,BIT);
sbi(REGISTER,BIT);
```
