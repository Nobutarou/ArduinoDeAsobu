/***********************************************************************************************************************
* DISCLAIMER
* This software is supplied by Renesas Electronics Corporation and is only intended for use with Renesas products.
* No other uses are authorized. This software is owned by Renesas Electronics Corporation and is protected under all
* applicable laws, including copyright laws. 
* THIS SOFTWARE IS PROVIDED "AS IS" AND RENESAS MAKES NO WARRANTIES REGARDING THIS SOFTWARE, WHETHER EXPRESS, IMPLIED
* OR STATUTORY, INCLUDING BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NON-INFRINGEMENT.  ALL SUCH WARRANTIES ARE EXPRESSLY DISCLAIMED.TO THE MAXIMUM EXTENT PERMITTED NOT PROHIBITED BY
* LAW, NEITHER RENESAS ELECTRONICS CORPORATION NOR ANY OF ITS AFFILIATED COMPANIES SHALL BE LIABLE FOR ANY DIRECT,
* INDIRECT, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES FOR ANY REASON RELATED TO THIS SOFTWARE, EVEN IF RENESAS OR
* ITS AFFILIATES HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
* Renesas reserves the right, without notice, to make changes to this software and to discontinue the availability 
* of this software. By using this software, you agree to the additional terms and conditions found by accessing the 
* following link:
* http://www.renesas.com/disclaimer
*
* Copyright (C) 2020 Renesas Electronics Corporation. All rights reserved.
***********************************************************************************************************************/

/***********************************************************************************************************************
*  File Name    : TrueI2C.c
*  Description  : Main Program
*  Creation Date: 2025-10-10
*  This file was generated by Smart Configurator.
***********************************************************************************************************************/

// https://www.renesas.com/ja/document/apn/rl78g13-serial-interface-iica-master-transmissionreception-rev200
// （3）マスタ→スレーブ通信 3（データ～データ～ストップ・コンディション
// 図 1.4
// 注 ストップ・コンディション発行後、SCLA0 が立ち上がってからストップ・コンディションが生
// 成されるまでに標準モード設定時 4.0μs 以上／ファースト・モード設定時 0.6μs 以上です。
//
// ストップコンディショントリガー SPT0=1 にしてから SCLA0 の立ち上りは、もし立ち上がり直後
// に SPT0=1 を発行したとすると 1/100kHz = 10usec
// 標準モードだったからさらに +4us。合計 14usec、きりの良いところで 22usec くらい待てば良
// いのか？

#include "r_smc_entry.h"
#include <string.h>

#define MCP23017_ADDRESS 0b01000000
#define MCP23017_IODIRA  0b00000000
#define MCP23017_IODIRB  0b00000001
#define MCP23017_GPIOA   0x12
#define MCP23017_GPIOB   0x13

int main(void);
void Ore_I2C_Send(uint8_t _reg, uint8_t _data);
uint8_t OreTxBuf[2];
volatile uint8_t _uart_end;
volatile uint8_t _i2c_send_end;

int main(void)
{
/* {{{ */
  uint8_t gpioa_reg; //GPIOA ポートのレジスタ
  uint8_t gpiob_reg; //GPIOB ポートのレジスタ

  EI();
  R_Config_UART1_Start();
  // MCP23017もどきの GPIOA を Output に
//  OreUART1_Send_U16(0);
//  OreUART1_Send_CRLF();

  Ore_I2C_Send(MCP23017_IODIRA, 0);

//  OreUART1_Send_U16(4);
//  OreUART1_Send_CRLF();

  // GPIOB を Output に
  Ore_I2C_Send(MCP23017_IODIRB, 0);

//  OreUART1_Send_U16(1);
//  OreUART1_Send_CRLF();
  
  // 全てのピンを Low に
  gpioa_reg=0;
  gpiob_reg=0;
  Ore_I2C_Send(MCP23017_GPIOA, gpioa_reg);

//  OreUART1_Send_U16(5);
//  OreUART1_Send_CRLF();

  Ore_I2C_Send(MCP23017_GPIOB, gpiob_reg);

//  OreUART1_Send_U16(2);
//  OreUART1_Send_CRLF();

  while(1)
  {
    //B5 を Low
    gpiob_reg = gpiob_reg & 0b11011111; 
    Ore_I2C_Send(MCP23017_GPIOB, gpiob_reg);
    //A0 を High
    gpioa_reg = gpioa_reg | 0b00000001; 
    Ore_I2C_Send(MCP23017_GPIOA, gpioa_reg);
    //待つ
    R_BSP_SoftwareDelay(1000, BSP_DELAY_MILLISECS); 
    
    //A0 を Low
    gpioa_reg = gpioa_reg & 0b11111110; 
    Ore_I2C_Send(MCP23017_GPIOA, gpioa_reg);
    //A1 を High
    gpioa_reg = gpioa_reg | 0b00000010; 
    Ore_I2C_Send(MCP23017_GPIOA, gpioa_reg);
    // I2C 送信は 1回にできるんだけど、ソースの法則性がややこしくなる、つまり GPIOA
    // と GPIOB に別々に送るみたいなときに、ルールを変えなくてはいけない、というようなこ
    // とを考えると、毎回送るほうが間違いが少ないと思う。Lチカにパフォーマンスもなにも無
    // いし。
    //待つ
    R_BSP_SoftwareDelay(1000, BSP_DELAY_MILLISECS); 
    
    //A1 を Low
    gpioa_reg = gpioa_reg & 0b11111101; 
    Ore_I2C_Send(MCP23017_GPIOA, gpioa_reg);
    //A2 を High
    gpioa_reg = gpioa_reg | 0b00000100; 
    Ore_I2C_Send(MCP23017_GPIOA, gpioa_reg);
    //待つ
    R_BSP_SoftwareDelay(1000, BSP_DELAY_MILLISECS); 
    
    //A2 を Low
    gpioa_reg = gpioa_reg & 0b11111011; 
    Ore_I2C_Send(MCP23017_GPIOA, gpioa_reg);
    //B0 を High
    gpiob_reg = gpiob_reg | 0b00000001; 
    Ore_I2C_Send(MCP23017_GPIOB, gpiob_reg);
    //待つ
    R_BSP_SoftwareDelay(1000, BSP_DELAY_MILLISECS); 
    
    //B0 を Low
    gpiob_reg = gpiob_reg & 0b11111110; 
    Ore_I2C_Send(MCP23017_GPIOB, gpiob_reg);
    //B1 を High
    gpiob_reg = gpiob_reg | 0b00000010; 
    Ore_I2C_Send(MCP23017_GPIOB, gpiob_reg);
    //待つ
    R_BSP_SoftwareDelay(1000, BSP_DELAY_MILLISECS); 
    
    //B1 を Low
    gpiob_reg = gpiob_reg & 0b11111101; 
    Ore_I2C_Send(MCP23017_GPIOB, gpiob_reg);
    //B2 を High
    gpiob_reg = gpiob_reg | 0b00000100; 
    Ore_I2C_Send(MCP23017_GPIOB, gpiob_reg);
    //待つ
    R_BSP_SoftwareDelay(1000, BSP_DELAY_MILLISECS); 
    
    //B2 を Low
    gpiob_reg = gpiob_reg & 0b11111011; 
    Ore_I2C_Send(MCP23017_GPIOB, gpiob_reg);
    //B3 を High
    gpiob_reg = gpiob_reg | 0b00001000; 
    Ore_I2C_Send(MCP23017_GPIOB, gpiob_reg);
    //待つ
    R_BSP_SoftwareDelay(1000, BSP_DELAY_MILLISECS); 
    
    //B3 を Low
    gpiob_reg = gpiob_reg & 0b11110111; 
    Ore_I2C_Send(MCP23017_GPIOB, gpiob_reg);
    //B4 を High
    gpiob_reg = gpiob_reg | 0b00010000; 
    Ore_I2C_Send(MCP23017_GPIOB, gpiob_reg);
    //待つ
    R_BSP_SoftwareDelay(1000, BSP_DELAY_MILLISECS); 
    
    //B4 を Low
    gpiob_reg = gpiob_reg & 0b11101111; 
    Ore_I2C_Send(MCP23017_GPIOB, gpiob_reg);
    //B5 を High
    gpiob_reg = gpiob_reg | 0b00100000; 
    Ore_I2C_Send(MCP23017_GPIOB, gpiob_reg);
    //待つ
    R_BSP_SoftwareDelay(1000, BSP_DELAY_MILLISECS); 
  }

  return 0;
/* }}} */
}

void Ore_I2C_Send(uint8_t _reg, uint8_t _data)
{
/* {{{ */
  unsigned short err;

  _i2c_send_end = 0;

  // サンプルコード R01AN5825XX0100
  // uint8_t g_Tx_buff[257] = と定義してあり、
  // 最初がアドレスレジスタになっているみたい。
  // それで、これでアドレスレジスタを送ることになってる。
  // R_IICA0_Master_Send((sladr << 1 ), g_Tx_buff, 1 ) 
  OreTxBuf[0]=_reg;
  OreTxBuf[1]=_data;
  err = R_Config_IICA0_Master_Send( MCP23017_ADDRESS, OreTxBuf, 2, 10);
  //OreUART1_Send_U16(0);
  //OreUART1_Send_CRLF();

  if(err == MD_ERROR1){ 
    // I2C バスがビジーらしい
    //OreUART1_Send_U16(1);
    //OreUART1_Send_CRLF();
    while(1){};
  } else if(err == MD_ERROR2){
    //OreUART1_Send_U16(2);
    //OreUART1_Send_CRLF();
    while(1){};
  };
  while(_i2c_send_end!=1){
    //OreUART1_Send_U16(_i2c_send_end);
    //OreUART1_Send_CRLF();
  };
  _i2c_send_end = 0;
/* }}} */
}

