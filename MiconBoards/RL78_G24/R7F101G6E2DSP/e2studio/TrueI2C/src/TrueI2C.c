/***********************************************************************************************************************
* DISCLAIMER
* This software is supplied by Renesas Electronics Corporation and is only intended for use with Renesas products.
* No other uses are authorized. This software is owned by Renesas Electronics Corporation and is protected under all
* applicable laws, including copyright laws. 
* THIS SOFTWARE IS PROVIDED "AS IS" AND RENESAS MAKES NO WARRANTIES REGARDING THIS SOFTWARE, WHETHER EXPRESS, IMPLIED
* OR STATUTORY, INCLUDING BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NON-INFRINGEMENT.  ALL SUCH WARRANTIES ARE EXPRESSLY DISCLAIMED.TO THE MAXIMUM EXTENT PERMITTED NOT PROHIBITED BY
* LAW, NEITHER RENESAS ELECTRONICS CORPORATION NOR ANY OF ITS AFFILIATED COMPANIES SHALL BE LIABLE FOR ANY DIRECT,
* INDIRECT, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES FOR ANY REASON RELATED TO THIS SOFTWARE, EVEN IF RENESAS OR
* ITS AFFILIATES HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
* Renesas reserves the right, without notice, to make changes to this software and to discontinue the availability 
* of this software. By using this software, you agree to the additional terms and conditions found by accessing the 
* following link:
* http://www.renesas.com/disclaimer
*
* Copyright (C) 2020 Renesas Electronics Corporation. All rights reserved.
***********************************************************************************************************************/

/***********************************************************************************************************************
*  File Name    : TrueI2C.c
*  Description  : Main Program
*  Creation Date: 2025-10-10
*  This file was generated by Smart Configurator.
***********************************************************************************************************************/

// memo:
// UART には何もエラーはなく送信完了している。
// なので通信自体は出きてると思う
// てことは、送っているデータが間違っている
// 分からん。。。

#include "r_smc_entry.h"
#include <string.h>

#define DEBUG 1
#if DEBUG == 1
#define UART1_Start() R_Config_UART1_Start()
#define UART1_Send(...) R_Config_UART1_Send(__VA_ARGS__)
#define UART1_Wait R_BSP_SoftwareDelay(100, BSP_DELAY_MILLISECS)
#else
#define UART1_Start()
#define UART1_Send(...)
#define UART1_Wait
#endif

#define MCP23017_ADDRESS 0b01000000
#define MCP23017_IODIRA  0b00000000
#define MCP23017_IODIRB  0b00000001
#define MCP23017_GPIOA   0x12
#define MCP23017_GPIOB   0x13

int main(void);
void Ore_I2C_Send(uint8_t _reg, uint8_t _data);
//uint16_t OreTxBuf;
uint8_t OreTxBuf[2];

int main(void)
{
/* {{{ */
  uint8_t gpioa_reg; //GPIOA ポートのレジスタ
  uint8_t gpiob_reg; //GPIOB ポートのレジスタ
  #if DEBUG == 1
  char msg1[]="UART START\r\n";
  #endif

  EI();
  UART1_Start();
  UART1_Send( (unsigned char *)msg1, strlen(msg1));
  UART1_Wait;
  // MCP23017もどきの GPIOA を Output に
  Ore_I2C_Send(MCP23017_IODIRA, 0);
  // GPIOB を Output に
  Ore_I2C_Send(MCP23017_IODIRB, 0);
  
  // 全てのピンを Low に
  gpioa_reg=0;
  gpiob_reg=0;
  Ore_I2C_Send(MCP23017_GPIOA, gpioa_reg);
  Ore_I2C_Send(MCP23017_GPIOB, gpiob_reg);

  while(1)
  {
    //B5 を Low
    gpiob_reg = gpiob_reg & 0b11011111; 
    Ore_I2C_Send(MCP23017_GPIOB, gpiob_reg);
    //A0 を High
    gpioa_reg = gpioa_reg | 0b00000001; 
    Ore_I2C_Send(MCP23017_GPIOA, gpioa_reg);
    //待つ
    R_BSP_SoftwareDelay(1000, BSP_DELAY_MILLISECS); 
    
    //A0 を Low
    gpioa_reg = gpioa_reg & 0b11111110; 
    Ore_I2C_Send(MCP23017_GPIOA, gpioa_reg);
    //A1 を High
    gpioa_reg = gpioa_reg | 0b00000010; 
    Ore_I2C_Send(MCP23017_GPIOA, gpioa_reg);
    // I2C 送信は 1回にできるんだけど、ソースの法則性がややこしくなる、つまり GPIOA
    // と GPIOB に別々に送るみたいなときに、ルールを変えなくてはいけない、というようなこ
    // とを考えると、毎回送るほうが間違いが少ないと思う。Lチカにパフォーマンスもなにも無
    // いし。
    //待つ
    R_BSP_SoftwareDelay(1000, BSP_DELAY_MILLISECS); 
    
    //A1 を Low
    gpioa_reg = gpioa_reg & 0b11111101; 
    Ore_I2C_Send(MCP23017_GPIOA, gpioa_reg);
    //A2 を High
    gpioa_reg = gpioa_reg | 0b00000100; 
    Ore_I2C_Send(MCP23017_GPIOA, gpioa_reg);
    //待つ
    R_BSP_SoftwareDelay(1000, BSP_DELAY_MILLISECS); 
    
    //A2 を Low
    gpioa_reg = gpioa_reg & 0b11111011; 
    Ore_I2C_Send(MCP23017_GPIOA, gpioa_reg);
    //B0 を High
    gpiob_reg = gpiob_reg | 0b00000001; 
    Ore_I2C_Send(MCP23017_GPIOB, gpiob_reg);
    //待つ
    R_BSP_SoftwareDelay(1000, BSP_DELAY_MILLISECS); 
    
    //B0 を Low
    gpiob_reg = gpiob_reg & 0b11111110; 
    Ore_I2C_Send(MCP23017_GPIOB, gpiob_reg);
    //B1 を High
    gpiob_reg = gpiob_reg | 0b00000010; 
    Ore_I2C_Send(MCP23017_GPIOB, gpiob_reg);
    //待つ
    R_BSP_SoftwareDelay(1000, BSP_DELAY_MILLISECS); 
    
    //B1 を Low
    gpiob_reg = gpiob_reg & 0b11111101; 
    Ore_I2C_Send(MCP23017_GPIOB, gpiob_reg);
    //B2 を High
    gpiob_reg = gpiob_reg | 0b00000100; 
    Ore_I2C_Send(MCP23017_GPIOB, gpiob_reg);
    //待つ
    R_BSP_SoftwareDelay(1000, BSP_DELAY_MILLISECS); 
    
    //B2 を Low
    gpiob_reg = gpiob_reg & 0b11111011; 
    Ore_I2C_Send(MCP23017_GPIOB, gpiob_reg);
    //B3 を High
    gpiob_reg = gpiob_reg | 0b00001000; 
    Ore_I2C_Send(MCP23017_GPIOB, gpiob_reg);
    //待つ
    R_BSP_SoftwareDelay(1000, BSP_DELAY_MILLISECS); 
    
    //B3 を Low
    gpiob_reg = gpiob_reg & 0b11110111; 
    Ore_I2C_Send(MCP23017_GPIOB, gpiob_reg);
    //B4 を High
    gpiob_reg = gpiob_reg | 0b00010000; 
    Ore_I2C_Send(MCP23017_GPIOB, gpiob_reg);
    //待つ
    R_BSP_SoftwareDelay(1000, BSP_DELAY_MILLISECS); 
    
    //B4 を Low
    gpiob_reg = gpiob_reg & 0b11101111; 
    Ore_I2C_Send(MCP23017_GPIOB, gpiob_reg);
    //B5 を High
    gpiob_reg = gpiob_reg | 0b00100000; 
    Ore_I2C_Send(MCP23017_GPIOB, gpiob_reg);
    //待つ
    R_BSP_SoftwareDelay(1000, BSP_DELAY_MILLISECS); 
  }

  return 0;
/* }}} */
}

void Ore_I2C_Send(uint8_t _reg, uint8_t _data)
{
/* {{{ */
  unsigned short err;
  char msg1[]="ERR: BUS BUSY\r\n";
  char msg2[]="ERR: NO START CONDITION\r\n";
  char msg3[]="NO ERROR\r\n";
  char msg4[]="I2C Send Called\r\n";
  UART1_Send( (unsigned char *)msg4, strlen(msg4));
  UART1_Wait;

  // サンプルコード R01AN5825XX0100
  // uint8_t g_Tx_buff[257] = と定義してあり、
  // 最初がアドレスレジスタになっているみたい。
  // それで、これでアドレスレジスタを送ることになってる。
  // R_IICA0_Master_Send((sladr << 1 ), g_Tx_buff, 1 ) 
  OreTxBuf[0]=_reg;
  OreTxBuf[1]=_data;
  err = R_Config_IICA0_Master_Send( MCP23017_ADDRESS, OreTxBuf, 2, 10);

  if(err == MD_ERROR1){ 
    // I2C バスがビジーらしい
    UART1_Send( (unsigned char *)msg1, strlen(msg1));
    UART1_Wait;
    while(1){};
  } else if(err == MD_ERROR2){
    UART1_Send( (unsigned char *)msg2, strlen(msg2));
    UART1_Wait;
    while(1){};
  }
  UART1_Send( (unsigned char *)msg3, strlen(msg3));
  UART1_Wait;
/* }}} */
}

